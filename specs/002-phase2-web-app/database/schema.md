# Database Schema Specification

## Overview

**Database**: Neon Serverless PostgreSQL
**ORM**: SQLModel (Python backend) + Better Auth (Next.js frontend)
**Migration Tool**: Alembic (via SQLModel)
**Connection**: SSL required (Neon enforces)

This document specifies the database schema for Phase II of the todo application, including tables managed by Better Auth (users, sessions, accounts) and application tables (tasks).

## Connection Configuration

### Environment Variable
```bash
DATABASE_URL=postgresql://username:password@ep-xxx-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require
```

**Format**: `postgresql://[user]:[password]@[host]/[database]?sslmode=require`

### Connection Pooling
- **Min connections**: 0 (Neon auto-scales)
- **Max connections**: 10 (per backend instance)
- **Idle timeout**: 300 seconds
- **Connection timeout**: 30 seconds

## Tables Overview

| Table | Owner | Purpose |
|-------|-------|---------|
| `users` | Better Auth | User accounts |
| `sessions` | Better Auth | Active user sessions |
| `accounts` | Better Auth | Password hashes and provider info |
| `tasks` | Application | User tasks |

## Table: users

**Managed by**: Better Auth (auto-created via migrations)

### Schema
```sql
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    name VARCHAR(100),
    image TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Columns

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | VARCHAR(255) | PRIMARY KEY | Unique user identifier (generated by Better Auth) |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | User email address (lowercase) |
| `email_verified` | BOOLEAN | DEFAULT FALSE | Email verification status |
| `name` | VARCHAR(100) | NULL | User display name (optional) |
| `image` | TEXT | NULL | Profile picture URL (optional) |
| `created_at` | TIMESTAMP | DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | DEFAULT NOW() | Last update timestamp |

### Indexes
```sql
CREATE INDEX idx_users_email ON users(email);
```

### Constraints
- Email must be unique (case-insensitive)
- Email must be valid format (enforced at application level)
- ID format: `user_[random_string]` (generated by Better Auth)

### Example Data
```sql
INSERT INTO users (id, email, name, email_verified, created_at, updated_at)
VALUES (
    'user_clp1234567890',
    'john@example.com',
    'John Doe',
    FALSE,
    '2024-12-28 10:00:00',
    '2024-12-28 10:00:00'
);
```

## Table: sessions

**Managed by**: Better Auth (auto-created via migrations)

### Schema
```sql
CREATE TABLE sessions (
    id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### Columns

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | VARCHAR(255) | PRIMARY KEY | Session identifier |
| `user_id` | VARCHAR(255) | FOREIGN KEY, NOT NULL | References users.id |
| `expires_at` | TIMESTAMP | NOT NULL | Session expiration time |
| `created_at` | TIMESTAMP | DEFAULT NOW() | Session creation time |

### Indexes
```sql
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
```

### Constraints
- `user_id` must exist in `users` table
- Sessions cascade delete when user is deleted
- Expired sessions cleaned up periodically (Better Auth handles)

### Example Data
```sql
INSERT INTO sessions (id, user_id, expires_at, created_at)
VALUES (
    'session_abc123',
    'user_clp1234567890',
    '2025-01-04 10:00:00',  -- 7 days from now
    '2024-12-28 10:00:00'
);
```

## Table: accounts

**Managed by**: Better Auth (auto-created via migrations)

### Schema
```sql
CREATE TABLE accounts (
    id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    provider VARCHAR(50) NOT NULL,
    provider_account_id VARCHAR(255) NOT NULL,
    password_hash TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### Columns

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | VARCHAR(255) | PRIMARY KEY | Account identifier |
| `user_id` | VARCHAR(255) | FOREIGN KEY, NOT NULL | References users.id |
| `provider` | VARCHAR(50) | NOT NULL | Auth provider (e.g., 'email') |
| `provider_account_id` | VARCHAR(255) | NOT NULL | Provider-specific ID (email for email provider) |
| `password_hash` | TEXT | NULL | Bcrypt password hash (NULL for OAuth) |
| `created_at` | TIMESTAMP | DEFAULT NOW() | Account link creation time |

### Indexes
```sql
CREATE INDEX idx_accounts_user_id ON accounts(user_id);
CREATE UNIQUE INDEX idx_accounts_provider_id ON accounts(provider, provider_account_id);
```

### Constraints
- `user_id` must exist in `users` table
- Accounts cascade delete when user is deleted
- `password_hash` is NULL for OAuth providers (future enhancement)
- `password_hash` uses bcrypt (hashing handled by Better Auth)

### Example Data
```sql
INSERT INTO accounts (id, user_id, provider, provider_account_id, password_hash, created_at)
VALUES (
    'account_xyz789',
    'user_clp1234567890',
    'email',
    'john@example.com',
    '$2a$10$XYZ...abc',  -- bcrypt hash
    '2024-12-28 10:00:00'
);
```

## Table: tasks

**Managed by**: Application (created via SQLModel migrations)

### Schema
```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### Columns

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | SERIAL | PRIMARY KEY | Auto-incrementing task ID |
| `user_id` | VARCHAR(255) | FOREIGN KEY, NOT NULL | References users.id (task owner) |
| `title` | VARCHAR(200) | NOT NULL | Task title |
| `description` | TEXT | NULL | Task description (optional) |
| `completed` | BOOLEAN | DEFAULT FALSE | Completion status |
| `created_at` | TIMESTAMP | DEFAULT NOW() | Task creation timestamp |
| `updated_at` | TIMESTAMP | DEFAULT NOW() | Last update timestamp |

### Indexes
```sql
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_completed ON tasks(completed);
CREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);
```

**Index Rationale**:
- `idx_tasks_user_id`: Filter tasks by user (most common query)
- `idx_tasks_completed`: Filter by status (future enhancement)
- `idx_tasks_created_at`: Order by creation date (default sort)

### Constraints
- `user_id` must exist in `users` table
- Tasks cascade delete when user is deleted
- `title` cannot be empty (enforced at application level)
- `title` trimmed of leading/trailing whitespace
- `description` can be NULL or empty string

### Triggers
```sql
-- Auto-update updated_at on row modification
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_tasks_updated_at
BEFORE UPDATE ON tasks
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

### Example Data
```sql
INSERT INTO tasks (user_id, title, description, completed, created_at, updated_at)
VALUES
    ('user_clp1234567890', 'Buy groceries', 'Milk, eggs, bread', FALSE, '2024-12-28 10:30:00', '2024-12-28 10:30:00'),
    ('user_clp1234567890', 'Finish homework', 'Math assignment pages 10-15', TRUE, '2024-12-27 14:00:00', '2024-12-28 09:15:00'),
    ('user_clp1234567890', 'Call dentist', NULL, FALSE, '2024-12-26 08:00:00', '2024-12-26 08:00:00');
```

## Relationships

### ER Diagram
```
users (1) ──── (0..*) tasks
  │
  ├── (1) ──── (0..*) sessions
  │
  └── (1) ──── (0..*) accounts
```

### Relationship Details

**users → tasks** (One-to-Many):
- One user can have many tasks
- A task belongs to exactly one user
- Deleting a user deletes all their tasks (CASCADE)

**users → sessions** (One-to-Many):
- One user can have multiple active sessions
- A session belongs to exactly one user
- Deleting a user deletes all their sessions (CASCADE)

**users → accounts** (One-to-Many):
- One user can have multiple accounts (email, Google, GitHub, etc.)
- An account belongs to exactly one user
- Deleting a user deletes all their accounts (CASCADE)

## SQLModel Models (Backend)

### User Model
```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    email_verified: bool = Field(default=False)
    name: Optional[str] = Field(default=None, max_length=100)
    image: Optional[str] = Field(default=None)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Task Model
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

## Pydantic Schemas (API Request/Response)

### Task Schemas
```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class TaskCreate(BaseModel):
    """Request schema for creating a task"""
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)

class TaskUpdate(BaseModel):
    """Request schema for updating a task"""
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)

class TaskResponse(BaseModel):
    """Response schema for task endpoints"""
    id: int
    user_id: str
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Allow creation from ORM models
```

## Migrations

### Migration Strategy
1. **Better Auth migrations**: Run automatically when Better Auth initializes
2. **Application migrations**: Use Alembic via SQLModel

### Initial Migration
```python
# alembic/versions/001_initial.py
from alembic import op
import sqlalchemy as sa

def upgrade():
    # tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.String(length=255), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('completed', sa.Boolean(), server_default='false', nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_created_at', 'tasks', ['created_at'], postgresql_ops={'created_at': 'DESC'})

    # Trigger for updated_at
    op.execute("""
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = CURRENT_TIMESTAMP;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    """)

    op.execute("""
        CREATE TRIGGER update_tasks_updated_at
        BEFORE UPDATE ON tasks
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
    """)

def downgrade():
    op.execute('DROP TRIGGER IF EXISTS update_tasks_updated_at ON tasks')
    op.execute('DROP FUNCTION IF EXISTS update_updated_at_column')
    op.drop_index('idx_tasks_created_at', 'tasks')
    op.drop_index('idx_tasks_completed', 'tasks')
    op.drop_index('idx_tasks_user_id', 'tasks')
    op.drop_table('tasks')
```

## Query Examples

### Common Queries

**Get all tasks for a user**:
```sql
SELECT * FROM tasks
WHERE user_id = 'user_clp1234567890'
ORDER BY created_at DESC;
```

**Create a task**:
```sql
INSERT INTO tasks (user_id, title, description, completed)
VALUES ('user_clp1234567890', 'Buy groceries', 'Milk, eggs', FALSE)
RETURNING *;
```

**Update a task**:
```sql
UPDATE tasks
SET title = 'Buy groceries and snacks',
    description = 'Milk, eggs, chips',
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1 AND user_id = 'user_clp1234567890'
RETURNING *;
```

**Toggle completion**:
```sql
UPDATE tasks
SET completed = NOT completed,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1 AND user_id = 'user_clp1234567890'
RETURNING *;
```

**Delete a task**:
```sql
DELETE FROM tasks
WHERE id = 1 AND user_id = 'user_clp1234567890';
```

**Count tasks by status**:
```sql
SELECT completed, COUNT(*) as count
FROM tasks
WHERE user_id = 'user_clp1234567890'
GROUP BY completed;
```

## Performance Optimization

### Index Usage
- `idx_tasks_user_id`: Used in all task queries (WHERE user_id = ?)
- `idx_tasks_created_at`: Used for default sorting
- `idx_tasks_completed`: Reserved for future filtering feature

### Query Performance Targets
- Get all tasks for user: <50ms
- Create task: <30ms
- Update task: <30ms
- Delete task: <20ms

### Connection Pooling
```python
# database.py
from sqlmodel import create_engine, Session
from app.config import settings

# Connection pool configuration
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=10,          # Max concurrent connections
    max_overflow=5,        # Additional connections if pool full
    pool_timeout=30,       # Wait time for available connection
    pool_recycle=3600,     # Recycle connections after 1 hour
    echo=False,            # Disable SQL logging in production
)

def get_session():
    with Session(engine) as session:
        yield session
```

## Data Integrity

### Constraints Summary
1. **Foreign Keys**: All `user_id` fields reference `users.id`
2. **Cascade Deletes**: Deleting a user deletes all related data
3. **Unique Constraints**: User emails must be unique
4. **Not Null**: Critical fields cannot be NULL (user_id, email, title)
5. **Defaults**: Sensible defaults (completed=false, timestamps=now)

### Data Validation Layers
1. **Database**: Constraints, foreign keys, triggers
2. **ORM (SQLModel)**: Field types, lengths, relationships
3. **Pydantic**: Request validation, min/max lengths
4. **Application**: Business logic (trimming, normalization)

## Backup & Recovery

**Neon handles backups automatically**:
- Point-in-time recovery (PITR)
- Daily automated backups
- Retention: 7 days (free tier), configurable (paid)

**No manual backup needed for Phase II**.

## Security Considerations

### Sensitive Data
- **Passwords**: Stored as bcrypt hashes in `accounts.password_hash`
- **Tokens**: Stored in `sessions` table (encrypted by Better Auth)
- **User Data**: No PII beyond email and optional name

### Access Control
- **User Isolation**: All queries filtered by `user_id`
- **Row-Level Security**: Not implemented (enforced at application level)
- **SSL/TLS**: Required by Neon for all connections

### SQL Injection Prevention
- ✅ Parameterized queries (SQLModel handles)
- ✅ ORM prevents raw SQL injection
- ✅ No user input directly in SQL

## Testing Data

### Seed Data for Development
```sql
-- Create test users
INSERT INTO users (id, email, name, email_verified)
VALUES
    ('user_test1', 'alice@example.com', 'Alice', TRUE),
    ('user_test2', 'bob@example.com', 'Bob', TRUE);

-- Create test accounts (password: "password123")
INSERT INTO accounts (id, user_id, provider, provider_account_id, password_hash)
VALUES
    ('account_test1', 'user_test1', 'email', 'alice@example.com', '$2a$10$...'),
    ('account_test2', 'user_test2', 'email', 'bob@example.com', '$2a$10$...');

-- Create test tasks
INSERT INTO tasks (user_id, title, description, completed)
VALUES
    ('user_test1', 'Test task 1', 'Alice task 1', FALSE),
    ('user_test1', 'Test task 2', 'Alice task 2', TRUE),
    ('user_test2', 'Test task 3', 'Bob task 1', FALSE);
```

## Monitoring & Logging

### Neon Dashboard
- Query performance
- Connection count
- Database size
- Slow query log

### Application Logging
```python
import logging

logger = logging.getLogger(__name__)

# Log database operations
logger.info(f"Creating task for user {user_id}")
logger.error(f"Failed to delete task {task_id}: {error}")
```

## Document History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-12-28 | Initial database schema specification for Phase II |
