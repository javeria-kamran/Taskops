# Project Constitution: Evolution of Todo Application

## Project Identity

**Name:** Taskify - Spec-Driven Development Hackathon
**Version:** 1.0.0
**Type:** Educational Multi-Phase Cloud-Native Application
**Duration:** December 1, 2025 - January 18, 2026

## Core Mission

Build a production-grade todo application that evolves from a simple console app to a distributed, AI-powered, cloud-native system using spec-driven development with Claude Code and Spec-Kit Plus.

---

## Constitutional Principles

### 1. Spec-Driven Development First

**Principle:** Every feature must be specified before implementation.

**Implementation Rules:**
- All code must be generated by Claude Code from specifications
- Manual coding is prohibited - refine specs until output is correct
- Each feature requires a complete specification in `/specs/features/`
- Specifications must include user stories, acceptance criteria, and technical details
- Changes to features require spec updates first

**Quality Gates:**
- [ ] Feature spec exists in `/specs/features/`
- [ ] Spec includes user stories and acceptance criteria
- [ ] Technical implementation details are documented
- [ ] Spec reviewed and approved before implementation
- [ ] Implementation matches spec exactly

### 2. Agentic Development Workflow

**Principle:** Follow the structured workflow for all development.

**Workflow Steps:**
1. **Specify** - Write detailed feature specification
2. **Plan** - Generate implementation plan from spec
3. **Task Breakdown** - Decompose into actionable tasks
4. **Implement** - Execute via Claude Code
5. **Validate** - Verify against acceptance criteria

**Enforcement:**
- Each phase must document prompts and iterations
- Track all Claude Code interactions in version control
- Document refinement cycles in spec history
- Maintain audit trail of spec-to-implementation process

### 3. Progressive Enhancement

**Principle:** Build incrementally, validate each phase before advancing.

**Phase Progression:**
- **Phase I:** Console foundation (Basic Level features only)
- **Phase II:** Web transformation (Basic Level + persistence)
- **Phase III:** AI enhancement (Natural language interface)
- **Phase IV:** Local cloud (Kubernetes deployment)
- **Phase V:** Distributed cloud (Event-driven architecture)

**Constraints:**
- Cannot skip phases
- Must complete all deliverables before advancing
- Each phase builds on previous phase's foundation
- Maintain backward compatibility within phases

### 4. Clean Architecture & Separation of Concerns

**Principle:** Maintain clear boundaries between system components.

**Structural Rules:**

**Monorepo Organization:**
```
/
├── .spec-kit/           # Spec-Kit configuration
├── specs/               # All specifications
│   ├── overview.md
│   ├── architecture.md
│   ├── features/        # Feature specifications
│   ├── api/             # API & MCP tool specs
│   ├── database/        # Schema specifications
│   └── ui/              # UI specifications
├── frontend/            # Next.js application
│   ├── CLAUDE.md
│   └── ...
├── backend/             # FastAPI application
│   ├── CLAUDE.md
│   └── ...
├── CLAUDE.md            # Root instructions
└── README.md
```

**Layering:**
- Frontend: Presentation & user interaction only
- Backend: Business logic & API layer
- Database: Data persistence & integrity
- AI/MCP: Tool orchestration & natural language processing

**Communication:**
- Frontend → Backend: REST API only
- Backend → Database: SQLModel ORM only
- AI Agent → Backend: MCP tools only
- No cross-layer shortcuts or backdoors

### 5. Security by Design

**Principle:** Security is non-negotiable and built-in from the start.

**Authentication & Authorization:**
- All users must authenticate via Better Auth
- JWT tokens required for all API requests
- Token validation on every backend request
- User data isolation enforced at database query level

**API Security:**
```
Rule: Every endpoint must verify user identity
Pattern: /api/{user_id}/resource
Validation: JWT user_id must match URL user_id
Enforcement: Middleware on all routes
```

**Data Protection:**
- User can only access their own tasks
- No cross-user data leakage
- SQL injection prevention via SQLModel
- XSS prevention via proper escaping
- CSRF protection on state-changing operations

**Secret Management:**
- Never commit secrets to version control
- Environment variables for all sensitive config
- Shared secrets (JWT) between frontend/backend
- Separate secrets for dev/staging/production

### 6. Stateless & Scalable Design

**Principle:** All services must be horizontally scalable.

**Backend Statelessness:**
- No in-memory session storage
- All state persisted to database
- Each request is independent
- Any server instance can handle any request

**Chat/Conversation State:**
- Conversations stored in database
- Messages stored in database
- Agent context reconstructed from DB on each request
- MCP tools are stateless functions

**Benefits:**
- Horizontal scaling capability
- Server restarts don't lose state
- Load balancing across instances
- Kubernetes-ready architecture

### 7. Database as Single Source of Truth

**Principle:** All persistent state lives in the database.

**Data Models (Phase II+):**

**users** (Better Auth managed)
- id: string (PK)
- email: string (unique)
- name: string
- created_at: timestamp

**tasks**
- id: integer (PK)
- user_id: string (FK → users.id)
- title: string (not null)
- description: text (nullable)
- completed: boolean (default false)
- created_at: timestamp
- updated_at: timestamp

**conversations** (Phase III+)
- id: integer (PK)
- user_id: string (FK → users.id)
- created_at: timestamp
- updated_at: timestamp

**messages** (Phase III+)
- id: integer (PK)
- conversation_id: integer (FK → conversations.id)
- user_id: string (FK → users.id)
- role: enum('user', 'assistant')
- content: text
- created_at: timestamp

**Constraints:**
- All queries filtered by user_id
- Cascading deletes for user data
- Proper indexes for performance
- Database migrations for schema changes

### 8. AI Agent as Tool Orchestrator

**Principle:** AI agents coordinate MCP tools, not direct database access.

**Architecture (Phase III+):**
```
User → ChatKit → /api/chat → Agent → MCP Tools → Database
                                ↓
                        Conversation DB
```

**Agent Responsibilities:**
- Interpret natural language intent
- Select appropriate MCP tool(s)
- Chain multiple tools if needed
- Provide human-friendly responses
- Handle tool errors gracefully

**Agent Constraints:**
- Never direct database access
- All actions via MCP tools
- No business logic in agent code
- Stateless operation per request

**MCP Tools Specification:**
- `add_task(user_id, title, description)` → task_id
- `list_tasks(user_id, status)` → task[]
- `complete_task(user_id, task_id)` → task
- `delete_task(user_id, task_id)` → task
- `update_task(user_id, task_id, title, description)` → task

**Tool Design Principles:**
- One clear purpose per tool
- User_id required on all tools
- Return structured data
- Handle errors with clear messages
- Idempotent where possible

### 9. Cloud-Native from Day One

**Principle:** Design for containerization and orchestration from the start.

**Containerization (Phase IV+):**
- Every service in its own container
- Dockerfile for frontend
- Dockerfile for backend
- Dockerfile for MCP server
- Docker Compose for local development

**Kubernetes Readiness:**
- Stateless services (horizontal scaling)
- Health check endpoints
- Graceful shutdown handling
- Configuration via environment variables
- External service discovery

**Deployment Targets:**
- Phase IV: Minikube (local Kubernetes)
- Phase V: DigitalOcean DOKS (cloud Kubernetes)

**Infrastructure as Code:**
- Helm charts for Kubernetes deployments
- Version controlled configurations
- Separate configs for dev/staging/prod
- kubectl-ai and kagent for management

### 10. Event-Driven Architecture (Phase V)

**Principle:** Services communicate via events for loose coupling.

**Event Infrastructure:**
- Apache Kafka for event streaming
- Dapr for service mesh & pub/sub
- Event sourcing for audit trail
- CQRS pattern for read/write separation

**Event Types:**
- `task.created`
- `task.updated`
- `task.completed`
- `task.deleted`
- `conversation.started`
- `message.sent`

**Benefits:**
- Service independence
- Async processing capability
- Audit trail & replay
- Scalable event consumers

### 11. Quality & Testing Standards

**Principle:** Automated validation at every level.

**Testing Requirements:**

**Phase I:**
- Unit tests for all business logic
- Test coverage > 80%
- Console input/output validation

**Phase II:**
- API endpoint tests
- Database integration tests
- Frontend component tests
- End-to-end user flows

**Phase III:**
- MCP tool tests
- Agent behavior tests
- Conversation persistence tests
- Natural language intent tests

**Phase IV/V:**
- Container tests
- Kubernetes deployment tests
- Load testing
- Chaos engineering tests

**CI/CD Pipeline:**
- Automated tests on every commit
- Deployment only if tests pass
- Staging environment validation
- Production deployment approval

### 12. Documentation & Knowledge Sharing

**Principle:** Code is read more than written - make it accessible.

**Required Documentation:**

**Repository Level:**
- `README.md` - Project overview & setup
- `CLAUDE.md` - Claude Code instructions
- `ARCHITECTURE.md` - System design
- `CHANGELOG.md` - Version history

**Spec Level:**
- `/specs/overview.md` - Project overview
- `/specs/features/*.md` - Feature specifications
- `/specs/api/*.md` - API contracts
- `/specs/database/*.md` - Schema documentation

**Code Level:**
- Clear function/class names (self-documenting)
- Comments only where logic is non-obvious
- Type hints in Python
- TypeScript for type safety

**Process Level:**
- Spec history folder for audit trail
- Prompt engineering documentation
- Iteration learnings captured
- Decision logs for architecture choices

---

## Technology Stack Mandates

### Phase I: Console Application
- **Language:** Python 3.13+
- **Package Manager:** UV
- **Spec Tools:** Claude Code + Spec-Kit Plus
- **Features:** Basic Level only (5 core operations)

### Phase II: Web Application
- **Frontend:** Next.js 16+ (App Router), TypeScript, Tailwind CSS
- **Backend:** Python FastAPI
- **ORM:** SQLModel
- **Database:** Neon Serverless PostgreSQL
- **Auth:** Better Auth with JWT
- **Deployment:** Vercel (frontend), Backend hosted service

### Phase III: AI Chatbot
- **UI Framework:** OpenAI ChatKit
- **AI Engine:** OpenAI Agents SDK
- **MCP Server:** Official MCP SDK (Python)
- **Persistence:** Neon PostgreSQL (conversations + messages)
- **Architecture:** Stateless chat endpoint

### Phase IV: Local Kubernetes
- **Containers:** Docker
- **Orchestration:** Minikube
- **Package Manager:** Helm
- **Management:** kubectl-ai, kagent

### Phase V: Cloud Deployment
- **Event Bus:** Apache Kafka
- **Service Mesh:** Dapr
- **Cloud Provider:** DigitalOcean Kubernetes (DOKS)
- **CI/CD:** GitHub Actions

---

## Feature Progression Framework

### Basic Level Features (Required: Phase I-V)
1. **Add Task** - Create new todo items
2. **Delete Task** - Remove tasks from list
3. **Update Task** - Modify existing task details
4. **View Task List** - Display all tasks
5. **Mark as Complete** - Toggle task completion status

### Intermediate Level Features (Optional: Bonus Points)
6. **Priorities & Tags** - Categorize tasks
7. **Search & Filter** - Find specific tasks
8. **Sort Tasks** - Reorder by criteria

### Advanced Level Features (Optional: Bonus Points)
9. **Recurring Tasks** - Auto-repeat tasks
10. **Due Dates & Reminders** - Time-based notifications

**Constraint:** Must complete all Basic Level features before implementing Intermediate/Advanced.

---

## API Design Principles

### RESTful Endpoints (Phase II+)

**Pattern:** `/api/{user_id}/{resource}`

**Endpoints:**
```
GET    /api/{user_id}/tasks           → List tasks
POST   /api/{user_id}/tasks           → Create task
GET    /api/{user_id}/tasks/{id}      → Get task details
PUT    /api/{user_id}/tasks/{id}      → Update task
DELETE /api/{user_id}/tasks/{id}      → Delete task
PATCH  /api/{user_id}/tasks/{id}/complete → Toggle completion
POST   /api/{user_id}/chat            → Chat endpoint (Phase III)
```

**Request/Response:**
- JSON format only
- Proper HTTP status codes
- Error responses with clear messages
- Pagination for list endpoints

**Authentication:**
- JWT token in `Authorization: Bearer <token>` header
- Token validation middleware
- User ID extraction from token
- URL user_id must match token user_id

### MCP Tools API (Phase III+)

**Tools:** Exposed via Official MCP SDK

**Tool Naming:** `{verb}_{noun}` (e.g., `add_task`, `list_tasks`)

**Parameters:**
- Always include `user_id` for security
- Required parameters clearly documented
- Optional parameters with defaults
- Type validation on all inputs

**Returns:**
- Structured data (not strings)
- Consistent error format
- Success status indicators
- Relevant object details

---

## Development Workflow

### Daily Workflow

1. **Morning:** Review current phase requirements
2. **Specify:** Write/update feature spec in `/specs/features/`
3. **Plan:** Generate implementation plan via Claude Code
4. **Task:** Break down into granular tasks
5. **Implement:** Execute tasks via Claude Code
6. **Validate:** Test against acceptance criteria
7. **Document:** Update specs and commit with clear messages
8. **Evening:** Push progress, update project board

### Weekly Workflow

1. **Sunday Evening:** Phase deadline - submit deliverables
2. **Monday:** Review feedback, plan next phase
3. **Mid-week:** Daily workflow (specify → implement)
4. **Friday:** Integration testing, bug fixes
5. **Saturday:** Demo preparation, documentation polish

### Phase Transition

1. Complete all deliverables for current phase
2. Create submission package (repo, demo, video)
3. Submit via Google Form
4. Attend live presentation (if invited)
5. Review phase learnings
6. Set up next phase environment
7. Begin next phase specifications

---

## Submission Requirements

### Every Phase Submission

**GitHub Repository:**
- Public repository with clear name
- Complete source code
- `/specs` folder with all specifications
- `constitution.md` file
- `README.md` with setup instructions
- `CLAUDE.md` with Claude Code guidelines
- Clear commit history showing spec-driven process

**Live Deployment:**
- Working application hosted online
- Vercel for frontend (Phase II+)
- Backend deployed and accessible
- Database configured and accessible

**Demo Video:**
- Maximum 90 seconds duration
- Screen recording of application features
- Voice-over explanation of spec-driven process
- Highlight key features and architecture
- Upload to YouTube/Vimeo (unlisted OK)

**Submission Form:**
- Google Form: https://forms.gle/KMKEKaFUD6ZX4UtY8
- Include all required links
- WhatsApp number for live presentation invitation

### Phase-Specific Requirements

**Phase I:**
- Console application video demo
- Python source code
- Basic Level features working
- Spec files for all features

**Phase II:**
- Web application live deployment
- REST API documentation
- Better Auth working
- Multi-user isolation verified

**Phase III:**
- Chatbot interface live
- Natural language commands working
- MCP server implementation
- Conversation persistence demonstrated

**Phase IV:**
- Minikube deployment working
- Helm charts provided
- kubectl-ai usage demonstrated
- Local Kubernetes video demo

**Phase V:**
- DOKS deployment live
- Kafka + Dapr integration
- Event-driven architecture explained
- Load testing results

---

## Scoring & Evaluation

### Base Points (1000 total)

| Phase | Points | Due Date | Description |
|-------|--------|----------|-------------|
| Phase I | 100 | Dec 7, 2025 | Console app |
| Phase II | 150 | Dec 14, 2025 | Web app |
| Phase III | 200 | Dec 21, 2025 | AI chatbot |
| Phase IV | 250 | Jan 4, 2026 | Local K8s |
| Phase V | 300 | Jan 18, 2026 | Cloud deployment |

### Bonus Points (600 possible)

| Feature | Points | Description |
|---------|--------|-------------|
| Reusable Intelligence | +200 | Claude Code Subagents & Skills |
| Cloud-Native Blueprints | +200 | Agent Skills for K8s patterns |
| Multi-language Support | +100 | Urdu language in chatbot |
| Voice Commands | +200 | Voice input for todos |

### Evaluation Criteria

**Spec-Driven Process (30%):**
- Quality of specifications
- Completeness of spec coverage
- Spec-to-implementation fidelity
- Iteration and refinement documentation

**Technical Implementation (40%):**
- Code quality and architecture
- Feature completeness
- Security implementation
- Performance and scalability

**Documentation (15%):**
- README clarity
- Spec documentation
- Code comments (where needed)
- Architecture diagrams

**Demo & Presentation (15%):**
- Video quality
- Feature demonstration
- Explanation clarity
- Live presentation (if invited)

---

## Constraints & Boundaries

### Hard Constraints (Non-Negotiable)

1. **No Manual Coding:** All code via Claude Code from specs
2. **Technology Stack:** Must use specified technologies per phase
3. **Security:** User isolation and JWT auth required (Phase II+)
4. **Stateless:** All services must be stateless (Phase III+)
5. **MCP Tools:** AI agents must use MCP, not direct DB access (Phase III+)
6. **Basic Features First:** Must complete all Basic Level before extras
7. **Phase Order:** Cannot skip phases
8. **Submission Deadlines:** No late submissions accepted

### Soft Constraints (Recommended)

1. **Test Coverage:** Aim for >80% coverage
2. **Response Time:** API responses < 200ms (p95)
3. **Code Duplication:** Minimize repeated code
4. **Bundle Size:** Frontend initial load < 200KB
5. **Database Queries:** Optimize N+1 queries

### Encouraged Exploration

1. **UI/UX Enhancements:** Better design than basic requirements
2. **Additional Features:** After Basic Level complete
3. **Performance Optimization:** Advanced caching, CDN usage
4. **Observability:** Logging, monitoring, tracing
5. **Accessibility:** WCAG compliance
6. **Internationalization:** Multi-language support

---

## Anti-Patterns to Avoid

### Code Anti-Patterns

❌ **Manual Coding:** Writing implementation without spec-driven process
✅ **Correct:** Write spec → Claude Code generates implementation

❌ **Stateful Backend:** Storing user sessions in memory
✅ **Correct:** Persist all state to database

❌ **Direct Database Access from Agent:** AI directly querying DB
✅ **Correct:** Agent uses MCP tools only

❌ **Secrets in Code:** API keys hardcoded in source
✅ **Correct:** Environment variables for all secrets

❌ **Cross-User Data Leakage:** Missing user_id filtering
✅ **Correct:** All queries filtered by authenticated user

### Architecture Anti-Patterns

❌ **Monolith with Tight Coupling:** Frontend calling DB directly
✅ **Correct:** Clean layer separation with clear APIs

❌ **Synchronous Everything:** Blocking calls for slow operations
✅ **Correct:** Event-driven async processing (Phase V)

❌ **No Error Handling:** Crashes on unexpected input
✅ **Correct:** Graceful error handling with user feedback

❌ **Missing Validation:** Trusting user input
✅ **Correct:** Input validation at system boundaries

### Process Anti-Patterns

❌ **Spec After Implementation:** Writing spec to match code
✅ **Correct:** Spec first, implementation follows

❌ **Skipping Phases:** Jumping to Phase V without I-IV
✅ **Correct:** Complete each phase sequentially

❌ **No Documentation:** Code without explanation
✅ **Correct:** README, CLAUDE.md, and spec documentation

❌ **Large Commits:** 1000+ line commits without context
✅ **Correct:** Small, focused commits with clear messages

---

## Success Criteria

### Phase I Success

- [ ] Console app runs without errors
- [ ] All 5 Basic Level features working
- [ ] Spec-driven process documented
- [ ] GitHub repo with specs folder
- [ ] Demo video submitted

### Phase II Success

- [ ] Web app deployed on Vercel
- [ ] Backend API deployed and accessible
- [ ] Better Auth working with JWT
- [ ] Multi-user data isolation verified
- [ ] All Phase I features in web interface

### Phase III Success

- [ ] ChatKit UI deployed
- [ ] Natural language commands working
- [ ] MCP server with 5 tools implemented
- [ ] Conversations persist to database
- [ ] Stateless chat endpoint working
- [ ] Agent uses MCP tools (not direct DB)

### Phase IV Success

- [ ] Docker containers for all services
- [ ] Minikube deployment working locally
- [ ] Helm charts created
- [ ] kubectl-ai/kagent usage demonstrated
- [ ] All Phase III features in Kubernetes

### Phase V Success

- [ ] DOKS cloud deployment live
- [ ] Kafka event streaming working
- [ ] Dapr service mesh configured
- [ ] Event-driven architecture implemented
- [ ] Load testing passed (100+ concurrent users)
- [ ] All previous features working in cloud

---

## Contact & Support

**Submission Form:** https://forms.gle/KMKEKaFUD6ZX4UtY8

**Live Presentations:**
- **When:** Sundays at 8:00 PM (Dec 7, 14, 21, Jan 4, 18)
- **Where:** Zoom - https://us06web.zoom.us/j/84976847088?pwd=Z7t7NaeXwVmmR5fysCv7NiMbfbhIda.1
- **Meeting ID:** 849 7684 7088
- **Passcode:** 305850

**Note:** All submissions evaluated. Live presentation by invitation only (does not affect scoring).

---

## Conclusion

This constitution serves as the guiding document for the entire Evolution of Todo hackathon. It establishes the principles, constraints, and quality standards that ensure a successful spec-driven development journey from console app to cloud-native AI system.

**Remember:**
- Spec first, code second
- Security is non-negotiable
- Stateless services enable scale
- AI agents orchestrate, don't implement
- Documentation is as important as code
- Progressive enhancement, phase by phase

**Success Formula:**
```
Clear Spec + Claude Code + Iterations = Working Implementation
Working Implementation × 5 Phases = Cloud-Native AI System
System + Documentation + Demo = Hackathon Success
```

---

**Version:** 1.0.0
**Last Updated:** December 27, 2025
**Next Review:** After Phase I completion
